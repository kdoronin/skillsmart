## Отчёт
За задачами для решения в концепции TDD я обратился к ChatGPT.

Среди прочих, он предложил мне вот эти три:
1. Калькулятор операций с дробями. Разработайте функции для выполнения основных арифметических операций (сложение, вычитание, умножение, деление) с дробями.
2. Система управления задачами (Todo List). Разработайте простую систему управления задачами, которая позволяет добавлять задачи, удалять их и отмечать выполненные.
3. Игра "Крестики-нолики". Разработайте логику для игры "Крестики-нолики" на поле 3x3. Напишите тесты для проверки корректности ходов, определения победителя или ничьи и блокировки ходов после завершения игры.

Я использовал алгоритм, который представлен в оригинальной книге по TDD. Собственно, вот он:
1. Быстро создать новый тест 
2. Запустить все тесты и убедиться, что новый тест терпит неудачу
3. Внести небольшие изменения
4. Снова запустить все тесты и убедиться, что на этот раз все тесты выполнились успешно
5. Провести рефакторинг для устранения дублирования

Учитывая, что задачи достаточно небольшие и все решаются за счёт только одного класса,
пункт №5 я практически не использовал. Так что цикл происходил с пункта 1 по пункт 4.

### Калькулятор операций с дробями
Практически не было ситуаций, когда внесённые изменения не являлись шагом на пути к запуску тестов без ошибок.
Начинал я, по заветам книги, с минимальных шагов. То есть писал по одному тесту в методе тестирования метода класса,
а затем добавлял функциональность в сам метод. Спустя 3-4 итерации, когда общая структура программы сформировалась,
я перешёл на чуть более крупные шаги. Так как метод "вычитание" – это обратный метод для "сложения". 
Поэтому я добавлял сразу несколько тестов и лишь после этого шёл вносить изменения, позволяющие всем им выполниться без ошибок.

Заметил интересный момент: за счёт подхода TDD, можно очень тонко регулировать уровень "проработанности" программы.
Например, в качестве примера, я не уходил в рамках тестов в случаи, когда передан заведомо неверный аргумент.
Но при желании этот путь можно проделать и явным образом отследить прогресс в покрытии тест-кейсов.

С другой стороны, подход позволяет достаточно быстро сформировать базовую функциональность класса на случай, 
если требуется показать её внешнему заказчику.

### Система управления задачами (Todo List)
Оказалось, что базовая функциональность класса может быть сформирована всего за 3-4 итерации. Но маленькие шаги позволяют
и сам код писать куда лаконичнее, чем попытка с наскока написать всё сразу.


### Игра "Крестики-нолики"
Сама игра была реализована также очень быстро. Буквально за 3-4 итерации. Поэтому добавил надёжности и написал тесты
для исключительных ситуаций. И даже они в случае с этой задачей не заняли много времени.


## Выводы
Подход TDD хорош тем, что позволяет делать быстрые шаги без долгого раздумывания над программой. 

Он безоговорочно полезен, когда нужно разработать что-то небольшое, в пределах 1000 строк и есть уверенность, что
система не будет разрастаться в будущем. Например, TDD хорошо использовать для микросервисной архитектуры.

Есть сомнения в его применимости для больших проектов. Так как в этом случае необходимо продумать систему хотя бы 
на уровне общей архитектуры. А вот если архитектура уже разработана, то на уровне Programming in small, TDD – это отличный подход.

Также очень понравилось, что можно максимально-тонко настроить отказоустойчивость системы.
Раскрывается TDD, когда начинаешь придумывать "сложные" тесты и дорабатывать программу под них.